<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Process Documents</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
    <div class="container mt-4">
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="/">Home</a></li>
                <li class="breadcrumb-item active" aria-current="page">Process Documents</li>
            </ol>
        </nav>
        
        <h1 class="mb-4">Process Documents</h1>
        
        <div class="card mb-4">
            <div class="card-header bg-primary text-white">
                <i class="bi bi-gear"></i> Processing Configuration
            </div>
            <div class="card-body">
                <form id="process-form">
                    <div class="card mb-3">
                        <div class="card-header bg-light">Chunking Settings</div>
                        <div class="card-body">
                            <div class="form-check form-switch mb-3">
                                <input class="form-check-input" type="checkbox" id="enable-chunking" checked>
                                <label class="form-check-label" for="enable-chunking">Enable Document Chunking</label>
                            </div>
                            
                            <div id="chunking-settings">
                                <div class="row mb-3">
                                    <div class="col-md-4">
                                        <label for="chunk-size" class="form-label">Maximum Chunk Size (characters)</label>
                                        <input type="number" class="form-control" id="chunk-size" value="500" min="100">
                                        <div class="form-text">Maximum size of each document chunk</div>
                                    </div>
                                    
                                    <div class="col-md-4">
                                        <label for="min-size" class="form-label">Minimum Chunk Size (characters)</label>
                                        <input type="number" class="form-control" id="min-size" value="100" min="50">
                                        <div class="form-text">Minimum size before creating a new chunk</div>
                                    </div>
                                    
                                    <div class="col-md-4">
                                        <label for="overlap" class="form-label">Chunk Overlap (characters)</label>
                                        <input type="number" class="form-control" id="overlap" value="100" min="0">
                                        <div class="form-text">Overlap between adjacent chunks</div>
                                    </div>
                                </div>
                                
                                <div class="mb-3">
                                    <label for="embedding-model" class="form-label">Embedding Model</label>
                                    <select class="form-select" id="embedding-model">
                                        <option value="" selected>Default Model</option>
                                        <!-- Models will be loaded dynamically -->
                                    </select>
                                    <div class="form-text">Select a model to use for generating embeddings</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card mb-3">
                        <div class="card-header bg-light">Semantic Enrichment</div>
                        <div class="card-body">
                            <div class="form-check form-switch mb-3">
                                <input class="form-check-input" type="checkbox" id="enable-enrichment" checked>
                                <label class="form-check-label" for="enable-enrichment">Enable Semantic Enrichment</label>
                            </div>
                            <div id="enrichment-settings" class="mb-3">
                                <label for="enrichment-model" class="form-label">Enrichment Model</label>
                                <select class="form-select" id="enrichment-model">
                                    <option value="" selected>Default Model</option>
                                    <!-- Models will be loaded dynamically -->
                                </select>
                                <div class="form-text">Select a model to use for generating semantic enrichment</div>
                            </div>
                            <p class="text-muted small mb-0">
                                When enabled, the LLM will generate additional content for each chunk, including key concepts, synonyms, 
                                and related topics to enhance retrieval quality. This makes documents easier to find with natural language queries.
                            </p>
                        </div>
                    </div>
                    
                    <div class="card mb-3">
                        <div class="card-header bg-light">Question Generation</div>
                        <div class="card-body">
                            <div class="form-check form-switch mb-3">
                                <input class="form-check-input" type="checkbox" id="enable-questions" checked>
                                <label class="form-check-label" for="enable-questions">Generate Questions for Chunks</label>
                            </div>
                            <div id="question-settings">
                                <div class="mb-3">
                                    <label for="max-questions" class="form-label">Maximum Questions per Chunk</label>
                                    <input type="number" class="form-control" id="max-questions" value="5" min="1" max="10">
                                    <div class="form-text">Maximum number of questions to generate for each chunk</div>
                                </div>
                                <div class="mb-3">
                                    <label for="questions-model" class="form-label">Question Generation Model</label>
                                    <select class="form-select" id="questions-model">
                                        <option value="" selected>Default Model</option>
                                        <!-- Models will be loaded dynamically -->
                                    </select>
                                    <div class="form-text">Select a model to use for generating questions</div>
                                </div>
                            </div>
                            <p class="text-muted small mb-0">
                                When enabled, the selected LLM will generate potential questions that can be answered by each chunk.
                                This helps match user queries directly to pre-generated Q&A pairs for improved response accuracy.
                            </p>
                        </div>
                    </div>
                    
                    <button type="submit" class="btn btn-primary" id="process-button">
                        <span id="process-spinner" class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
                        Process Documents
                    </button>
                </form>
            </div>
        </div>
        
        <div class="row mb-4">
            <!-- Upload File Card -->
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header bg-warning text-dark d-flex justify-content-between align-items-center">
                        <div>
                            <i class="bi bi-upload"></i> Upload File
                        </div>
                    </div>
                    <div class="card-body">
                        <form id="upload-form" enctype="multipart/form-data">
                            <div class="mb-3">
                                <label for="file-upload" class="form-label">Select a file to upload</label>
                                <input class="form-control" type="file" id="file-upload" accept=".txt,.pdf">
                                <div class="form-text">Supported file types: TXT, PDF</div>
                            </div>
                            <div class="form-check mb-3">
                                <input class="form-check-input" type="checkbox" id="process-immediately" checked>
                                <label class="form-check-label" for="process-immediately">
                                    Process immediately after upload
                                </label>
                            </div>
                            <div class="d-flex">
                                <button type="submit" class="btn btn-warning me-2" id="upload-button">
                                    <span id="upload-spinner" class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
                                    Upload File
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            </div>

            <!-- Database Management Card -->
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header bg-danger text-white d-flex justify-content-between align-items-center">
                        <div>
                            <i class="bi bi-trash"></i> Database Management
                        </div>
                    </div>
                    <div class="card-body">
                        <p class="mb-3">Clear all documents from the vector database (ChromaDB) and Elasticsearch (if enabled). <strong>This action cannot be undone.</strong></p>
                        <button type="button" class="btn btn-danger" id="clear-db-button" data-bs-toggle="modal" data-bs-target="#clearDbModal">
                            <i class="bi bi-trash"></i> Clear All Databases
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Clear DB Confirmation Modal -->
        <div class="modal fade" id="clearDbModal" tabindex="-1" aria-labelledby="clearDbModalLabel" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header bg-danger text-white">
                        <h5 class="modal-title" id="clearDbModalLabel">Confirm Database Clear</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <p><strong>Warning:</strong> This will permanently delete all documents from both ChromaDB and Elasticsearch (if enabled). This action cannot be undone.</p>
                        <p>Are you sure you want to proceed?</p>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-danger" id="confirm-clear-db">
                            <span id="clear-db-spinner" class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
                            Clear All Databases
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- All Jobs Card -->
        <div class="card mb-4 d-none" id="all-jobs-card">
            <div class="card-header bg-secondary text-white d-flex justify-content-between align-items-center">
                <div>
                    <i class="bi bi-list-check"></i> Recent Jobs
                </div>
                <div>
                    <button class="btn btn-sm btn-light" id="refresh-jobs-btn">
                        <i class="bi bi-arrow-clockwise"></i> Refresh
                    </button>
                </div>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-striped table-hover">
                        <thead>
                            <tr>
                                <th>Job ID</th>
                                <th>Status</th>
                                <th>Progress</th>
                                <th>Files</th>
                                <th>Success</th>
                                <th>Failed</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="jobs-table-body">
                            <!-- Jobs will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <!-- Job Status Card - Initially Hidden -->
        <div class="card mb-4 d-none" id="job-status-card">
            <div class="card-header bg-info text-white d-flex justify-content-between align-items-center">
                <div>
                    <i class="bi bi-clock-history"></i> Processing Job Status
                </div>
                <div>
                    <span class="badge bg-light text-dark job-id-badge" id="job-id-display"></span>
                </div>
            </div>
            <div class="card-body">
                <div class="d-flex justify-content-between mb-2">
                    <div>
                        <span class="badge" id="job-status-badge">Queued</span>
                    </div>
                    <div>
                        <small>Started: <span id="job-started-time">Just now</span></small>
                    </div>
                </div>
                
                <div class="progress mb-3" style="height: 25px;">
                    <div id="job-progress-bar" class="progress-bar progress-bar-striped progress-bar-animated" 
                         role="progressbar" style="width: 0%;" 
                         aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                </div>
                
                <div class="job-stats mb-3">
                    <div class="row text-center">
                        <div class="col-md-3">
                            <div class="stat-item">
                                <div class="stat-value" id="stat-files">0</div>
                                <div class="stat-label">Files</div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="stat-item">
                                <div class="stat-value" id="stat-processed">0</div>
                                <div class="stat-label">Processed</div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="stat-item">
                                <div class="stat-value text-success" id="stat-success">0</div>
                                <div class="stat-label">Success</div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="stat-item">
                                <div class="stat-value text-danger" id="stat-failed">0</div>
                                <div class="stat-label">Failed</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="d-flex justify-content-end">
                    <button class="btn btn-sm btn-outline-secondary me-2" id="stop-polling-btn">
                        <i class="bi bi-pause-circle"></i> Stop Updates
                    </button>
                    <button class="btn btn-sm btn-outline-primary d-none" id="resume-polling-btn">
                        <i class="bi bi-play-circle"></i> Resume Updates
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Result Card - Shows Final Results -->
        <div class="card mb-4 d-none" id="result-card">
            <div class="card-header bg-success text-white">
                <i class="bi bi-check-circle"></i> Processing Results
            </div>
            <div class="card-body" id="result-content">
            </div>
        </div>
        
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Elements - Form and Settings
            const enableChunkingSwitch = document.getElementById('enable-chunking');
            const chunkingSettings = document.getElementById('chunking-settings');
            const enableQuestionsSwitch = document.getElementById('enable-questions');
            const questionSettings = document.getElementById('question-settings');
            const processForm = document.getElementById('process-form');
            const processButton = document.getElementById('process-button');
            const processSpinner = document.getElementById('process-spinner');
            
            // Elements - Cards
            const jobStatusCard = document.getElementById('job-status-card');
            const resultCard = document.getElementById('result-card');
            const resultContent = document.getElementById('result-content');
            const allJobsCard = document.getElementById('all-jobs-card');
            
            // Elements - Job Status
            const jobIdDisplay = document.getElementById('job-id-display');
            const jobStatusBadge = document.getElementById('job-status-badge');
            const jobProgressBar = document.getElementById('job-progress-bar');
            const jobStartedTime = document.getElementById('job-started-time');
            
            // Elements - Job Stats
            const statFiles = document.getElementById('stat-files');
            const statProcessed = document.getElementById('stat-processed');
            const statSuccess = document.getElementById('stat-success');
            const statFailed = document.getElementById('stat-failed');
            
            // Elements - Polling Controls
            const stopPollingBtn = document.getElementById('stop-polling-btn');
            const resumePollingBtn = document.getElementById('resume-polling-btn');
            const refreshJobsBtn = document.getElementById('refresh-jobs-btn');
            const jobsTableBody = document.getElementById('jobs-table-body');
            
            // Polling variables
            let currentJobId = null;
            let pollingInterval = null;
            let isPolling = false;
            let jobStartTime = null;
            
            // Toggle chunking settings visibility
            enableChunkingSwitch.addEventListener('change', () => {
                if (enableChunkingSwitch.checked) {
                    chunkingSettings.classList.remove('d-none');
                } else {
                    chunkingSettings.classList.add('d-none');
                }
            });
            
            // Toggle question generation settings visibility
            enableQuestionsSwitch.addEventListener('change', () => {
                if (enableQuestionsSwitch.checked) {
                    questionSettings.classList.remove('d-none');
                } else {
                    questionSettings.classList.add('d-none');
                }
            });
            
            // Format time elapsed
            function formatTimeElapsed(startTime) {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                if (elapsed < 60) {
                    return `${elapsed} seconds ago`;
                } else if (elapsed < 3600) {
                    return `${Math.floor(elapsed / 60)} minutes ago`;
                } else {
                    return `${Math.floor(elapsed / 3600)} hours ago`;
                }
            }
            
            // Update job status display
            function updateJobStatusDisplay(jobData) {
                // Update progress bar
                const progress = jobData.progress || 0;
                jobProgressBar.style.width = `${progress}%`;
                jobProgressBar.setAttribute('aria-valuenow', progress);
                jobProgressBar.textContent = `${progress}%`;
                
                // Update status badge
                let statusClass = 'bg-secondary';
                switch(jobData.status) {
                    case 'queued':
                        statusClass = 'bg-secondary';
                        break;
                    case 'processing':
                        statusClass = 'bg-info';
                        break;
                    case 'completed':
                        statusClass = 'bg-success';
                        break;
                    case 'failed':
                        statusClass = 'bg-danger';
                        break;
                }
                jobStatusBadge.className = `badge ${statusClass}`;
                jobStatusBadge.textContent = jobData.status.charAt(0).toUpperCase() + jobData.status.slice(1);
                
                // Update stats
                statFiles.textContent = jobData.total_files || 0;
                statProcessed.textContent = jobData.processed_files || 0;
                statSuccess.textContent = jobData.successful_chunks || 0;
                statFailed.textContent = jobData.failed_chunks || 0;
                
                // Update time elapsed
                if (jobStartTime) {
                    jobStartedTime.textContent = formatTimeElapsed(jobStartTime);
                }
                
                // Handle job completion
                if (jobData.status === 'completed' || jobData.status === 'failed') {
                    // Stop polling
                    stopPolling();
                    
                    // Show the result card with final results
                    showResults(jobData);
                }
            }
            
            // Poll for job status
            async function pollJobStatus() {
                if (!currentJobId || !isPolling) return;
                
                try {
                    const response = await fetch(`/job/${currentJobId}`);
                    const jobData = await response.json();
                    
                    // Update the UI with job status
                    updateJobStatusDisplay(jobData);
                    
                } catch (error) {
                    console.error('Error polling job status:', error);
                }
            }
            
            // Start polling
            function startPolling(jobId) {
                if (pollingInterval) {
                    clearInterval(pollingInterval);
                }
                
                currentJobId = jobId;
                isPolling = true;
                jobStartTime = Date.now();
                
                // Initial poll
                pollJobStatus();
                
                // Set up polling interval (every 2 seconds)
                pollingInterval = setInterval(pollJobStatus, 2000);
                
                // Show polling controls
                stopPollingBtn.classList.remove('d-none');
                resumePollingBtn.classList.add('d-none');
            }
            
            // Stop polling
            function stopPolling() {
                isPolling = false;
                if (pollingInterval) {
                    clearInterval(pollingInterval);
                    pollingInterval = null;
                }
                
                // Update UI controls
                stopPollingBtn.classList.add('d-none');
                resumePollingBtn.classList.remove('d-none');
            }
            
            // Resume polling
            function resumePolling() {
                if (currentJobId) {
                    isPolling = true;
                    pollJobStatus();
                    pollingInterval = setInterval(pollJobStatus, 2000);
                    
                    // Update UI controls
                    stopPollingBtn.classList.remove('d-none');
                    resumePollingBtn.classList.add('d-none');
                }
            }
            
            // Show results in the result card
            function showResults(jobData) {
                if (!jobData.result) return;
                
                resultCard.classList.remove('d-none');
                const result = jobData.result;
                
                let resultHtml = '';
                
                // Add message
                if (result.message) {
                    const alertClass = result.failed_chunks > 0 ? 'alert-warning' : 'alert-success';
                    resultHtml += `<div class="alert ${alertClass}">${result.message}</div>`;
                }
                
                // Add statistics
                resultHtml += '<div class="row mt-3">';
                resultHtml += `<div class="col-md-3"><strong>Source Files:</strong> ${result.source_files || 0}</div>`;
                resultHtml += `<div class="col-md-3"><strong>Total Chunks:</strong> ${result.total_chunks || 0}</div>`;
                resultHtml += `<div class="col-md-3"><strong>Successful:</strong> ${result.successful_chunks || 0}</div>`;
                resultHtml += `<div class="col-md-3"><strong>Failed:</strong> ${result.failed_chunks || 0}</div>`;
                resultHtml += '</div>';
                
                // Add semantic enrichment status if available
                if (result.semantic_enrichment) {
                    const enrichment = result.semantic_enrichment;
                    const statusColor = enrichment.enabled ? 'success' : 'secondary';
                    resultHtml += `
                        <div class="mt-3">
                            <h5>Semantic Enrichment</h5>
                            <div class="badge bg-${statusColor} mb-2">${enrichment.enabled ? 'Enabled' : 'Disabled'}</div>
                            <p class="mb-0">Chunks processed with enrichment: ${enrichment.chunks_processed}</p>
                        </div>
                    `;
                }
                
                // Add question generation status if available
                if (result.question_generation) {
                    const questionGen = result.question_generation;
                    const statusColor = questionGen.enabled ? 'success' : 'secondary';
                    resultHtml += `
                        <div class="mt-3">
                            <h5>Question Generation</h5>
                            <div class="badge bg-${statusColor} mb-2">${questionGen.enabled ? 'Enabled' : 'Disabled'}</div>
                            <p class="mb-0">Chunks processed with questions: ${questionGen.chunks_processed}</p>
                            <p class="mb-0">Max questions per chunk: ${questionGen.max_questions_per_chunk}</p>
                        </div>
                    `;
                }
                
                // Add term extraction status if available
                if (result.term_extraction) {
                    const termExtraction = result.term_extraction;
                    const statusColor = termExtraction.terms_updated ? 'success' : 'warning';
                    resultHtml += `
                        <div class="mt-3">
                            <h5>Domain Term Extraction</h5>
                            <div class="badge bg-${statusColor} mb-2">${termExtraction.terms_updated ? 'Updated' : 'Failed'}</div>
                            ${termExtraction.terms_updated ? 
                                `<p class="mb-0">Terms updated: ${termExtraction.previous_term_count} â†’ ${termExtraction.new_term_count}</p>` : 
                                `<p class="mb-0 text-danger">Error: ${termExtraction.error}</p>`
                            }
                        </div>
                    `;
                }
                
                // Add failed items if any
                if (result.failed_chunks > 0 && result.failed_items) {
                    resultHtml += '<div class="mt-3">';
                    resultHtml += '<h5>Failed Items:</h5>';
                    resultHtml += '<div class="accordion" id="failedItemsAccordion">';
                    resultHtml += `
                        <div class="accordion-item">
                            <h2 class="accordion-header">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#failedItemsContent">
                                    ${result.failed_items.length} Failed Items
                                </button>
                            </h2>
                            <div id="failedItemsContent" class="accordion-collapse collapse">
                                <div class="accordion-body">
                                    <ul class="small text-danger">
                    `;
                    
                    result.failed_items.forEach(item => {
                        resultHtml += `<li>${item}</li>`;
                    });
                    
                    resultHtml += `
                                    </ul>
                                </div>
                            </div>
                        </div>
                    `;
                    resultHtml += '</div>';
                    resultHtml += '</div>';
                }
                
                resultContent.innerHTML = resultHtml;
            }
            
            // Load and display all jobs
            async function loadAllJobs() {
                try {
                    const response = await fetch('/jobs');
                    const data = await response.json();
                    
                    if (data.total_jobs > 0) {
                        // Show the all jobs card
                        allJobsCard.classList.remove('d-none');
                        
                        // Clear existing rows
                        jobsTableBody.innerHTML = '';
                        
                        // Sort jobs by newest first (assuming job_id has some timestamp component)
                        const sortedJobs = Object.entries(data.jobs).sort((a, b) => b[0].localeCompare(a[0]));
                        
                        // Add rows for each job
                        sortedJobs.forEach(([jobId, jobData]) => {
                            const row = document.createElement('tr');
                            
                            // Status badge
                            let statusClass = 'bg-secondary';
                            switch(jobData.status) {
                                case 'queued':
                                    statusClass = 'bg-secondary';
                                    break;
                                case 'processing':
                                    statusClass = 'bg-info';
                                    break;
                                case 'completed':
                                    statusClass = 'bg-success';
                                    break;
                                case 'failed':
                                    statusClass = 'bg-danger';
                                    break;
                            }
                            
                            row.innerHTML = `
                                <td><small class="text-muted">${jobId.substring(0, 8)}...</small></td>
                                <td><span class="badge ${statusClass}">${jobData.status}</span></td>
                                <td>
                                    <div class="progress" style="height: 15px;">
                                        <div class="progress-bar ${statusClass}" style="width: ${jobData.progress}%;" 
                                             aria-valuenow="${jobData.progress}" aria-valuemin="0" aria-valuemax="100">
                                             ${jobData.progress}%
                                        </div>
                                    </div>
                                </td>
                                <td>${jobData.total_files || 0}</td>
                                <td>${jobData.successful_chunks || 0}</td>
                                <td>${jobData.failed_chunks || 0}</td>
                                <td>
                                    <button class="btn btn-sm btn-outline-primary view-job-btn" data-job-id="${jobId}">
                                        <i class="bi bi-eye"></i>
                                    </button>
                                </td>
                            `;
                            
                            jobsTableBody.appendChild(row);
                        });
                        
                        // Add event listeners to view buttons
                        document.querySelectorAll('.view-job-btn').forEach(btn => {
                            btn.addEventListener('click', (e) => {
                                const jobId = e.currentTarget.getAttribute('data-job-id');
                                viewJob(jobId);
                            });
                        });
                    }
                } catch (error) {
                    console.error('Error loading jobs:', error);
                }
            }
            
            // View a specific job
            async function viewJob(jobId) {
                try {
                    const response = await fetch(`/job/${jobId}`);
                    const jobData = await response.json();
                    
                    // Setup the job status card
                    currentJobId = jobId;
                    jobIdDisplay.textContent = jobId.substring(0, 8) + '...';
                    jobStatusCard.classList.remove('d-none');
                    
                    // Update display
                    updateJobStatusDisplay(jobData);
                    
                    // If job is still running, start polling
                    if (jobData.status === 'queued' || jobData.status === 'processing') {
                        startPolling(jobId);
                    } else {
                        // For completed/failed jobs, just show the results
                        showResults(jobData);
                    }
                    
                    // Scroll to the job status card
                    jobStatusCard.scrollIntoView({ behavior: 'smooth' });
                    
                } catch (error) {
                    console.error('Error viewing job:', error);
                }
            }
            
            // File upload form
            const uploadForm = document.getElementById('upload-form');
            const fileUpload = document.getElementById('file-upload');
            const processImmediately = document.getElementById('process-immediately');
            const uploadButton = document.getElementById('upload-button');
            const uploadSpinner = document.getElementById('upload-spinner');
            
            // Clear DB elements
            const clearDbButton = document.getElementById('clear-db-button');
            const confirmClearDbButton = document.getElementById('confirm-clear-db');
            const clearDbModal = new bootstrap.Modal(document.getElementById('clearDbModal'));
            const clearDbSpinner = document.getElementById('clear-db-spinner');
            
            // Upload file form submission
            uploadForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                // Validate file
                if (!fileUpload.files || fileUpload.files.length === 0) {
                    alert('Please select a file to upload');
                    return;
                }
                
                const file = fileUpload.files[0];
                
                // Check file size (limit to 10MB)
                if (file.size > 10 * 1024 * 1024) {
                    alert('File size exceeds the 10MB limit');
                    return;
                }
                
                // Check file type
                if (!file.name.endsWith('.txt') && !file.name.endsWith('.pdf')) {
                    alert('Only .txt and .pdf files are supported');
                    return;
                }
                
                // Show spinner and disable button
                uploadSpinner.classList.remove('d-none');
                uploadButton.disabled = true;
                
                // Create form data
                const formData = new FormData();
                formData.append('file', file);
                formData.append('process_immediately', processImmediately.checked);
                
                // Add chunking settings from main form
                const enableChunking = enableChunkingSwitch.checked;
                const chunkSize = document.getElementById('chunk-size').value;
                const minSize = document.getElementById('min-size').value;
                const overlap = document.getElementById('overlap').value;
                const enableEnrichment = document.getElementById('enable-enrichment').checked;
                const enableQuestions = enableQuestionsSwitch.checked;
                const maxQuestions = document.getElementById('max-questions').value;
                
                // Add these settings to the form data
                formData.append('enable_chunking', enableChunking);
                formData.append('chunk_size', chunkSize);
                formData.append('min_size', minSize);
                formData.append('overlap', overlap);
                formData.append('enhance_chunks', enableEnrichment);
                formData.append('generate_questions', enableQuestions);
                formData.append('max_questions_per_chunk', maxQuestions);
                
                try {
                    // Send request to upload file
                    const response = await fetch('/api/upload-file', {
                        method: 'POST',
                        body: formData
                    });
                    
                    const data = await response.json();
                    
                    if (data.status === 'error') {
                        // Show error
                        resultCard.classList.remove('d-none');
                        resultContent.innerHTML = `<div class="alert alert-danger">${data.message}</div>`;
                    } else {
                        // Show success and start job tracking if processing immediately
                        resultCard.classList.remove('d-none');
                        resultContent.innerHTML = `<div class="alert alert-success">${data.message}</div>`;
                        
                        // If processing immediately, start tracking the job
                        if (processImmediately.checked && data.job_id) {
                            // Get the job ID 
                            const jobId = data.job_id;
                            
                            // Setup the job status card
                            currentJobId = jobId;
                            jobIdDisplay.textContent = jobId.substring(0, 8) + '...';
                            jobStatusCard.classList.remove('d-none');
                            
                            // Start polling for updates
                            startPolling(jobId);
                            
                            // Load all jobs
                            loadAllJobs();
                        }
                        
                        // Reset form
                        uploadForm.reset();
                    }
                } catch (error) {
                    // Show error
                    resultCard.classList.remove('d-none');
                    resultContent.innerHTML = `<div class="alert alert-danger">Error uploading file: ${error.message}</div>`;
                } finally {
                    // Hide spinner and enable button
                    uploadSpinner.classList.add('d-none');
                    uploadButton.disabled = false;
                }
            });
            
            // Clear database confirmation
            confirmClearDbButton.addEventListener('click', async () => {
                // Show spinner and disable button
                clearDbSpinner.classList.remove('d-none');
                confirmClearDbButton.disabled = true;
                
                try {
                    // Send request to clear DB
                    const response = await fetch('/api/clear-db', {
                        method: 'POST'
                    });
                    
                    const data = await response.json();
                    
                    // Hide modal
                    clearDbModal.hide();
                    
                    // Show result
                    resultCard.classList.remove('d-none');
                    
                    if (data.status === 'error') {
                        resultContent.innerHTML = `<div class="alert alert-danger">${data.message}</div>`;
                    } else {
                        // Create detailed result display
                        let resultHtml = `<div class="alert alert-success">${data.message}</div>`;
                        
                        // Add detailed results if available
                        if (data.result) {
                            resultHtml += '<div class="mt-3">';
                            
                            // ChromaDB results
                            if (data.result.chroma) {
                                const chromaResult = data.result.chroma;
                                resultHtml += `
                                    <div class="card mb-3">
                                        <div class="card-header bg-primary text-white">
                                            ChromaDB Results
                                        </div>
                                        <div class="card-body">
                                            <p><strong>Status:</strong> ${chromaResult.status}</p>
                                            <p><strong>Documents Removed:</strong> ${chromaResult.documents_removed}</p>
                                        </div>
                                    </div>
                                `;
                            }
                            
                            // Elasticsearch results
                            if (data.result.elasticsearch) {
                                const esResult = data.result.elasticsearch;
                                let headerClass = 'bg-primary';
                                
                                if (esResult.status === 'not_available') {
                                    headerClass = 'bg-secondary';
                                } else if (esResult.status === 'error') {
                                    headerClass = 'bg-danger';
                                }
                                
                                resultHtml += `
                                    <div class="card mb-3">
                                        <div class="card-header ${headerClass} text-white">
                                            Elasticsearch Results
                                        </div>
                                        <div class="card-body">
                                            <p><strong>Status:</strong> ${esResult.status}</p>
                                            ${esResult.status === 'success' ? 
                                                `<p><strong>Documents Removed:</strong> ${esResult.documents_removed}</p>` :
                                                esResult.status === 'error' ? 
                                                    `<p class="text-danger"><strong>Error:</strong> ${esResult.error}</p>` :
                                                    `<p>Elasticsearch is not enabled or configured.</p>`
                                            }
                                        </div>
                                    </div>
                                `;
                            }
                            
                            // Terms update status
                            if ('terms_updated' in data.result) {
                                resultHtml += `
                                    <div class="card mb-3">
                                        <div class="card-header ${data.result.terms_updated ? 'bg-success' : 'bg-warning'} text-white">
                                            Domain Terms Update
                                        </div>
                                        <div class="card-body">
                                            <p><strong>Status:</strong> ${data.result.terms_updated ? 'Success' : 'Failed'}</p>
                                            ${!data.result.terms_updated && data.result.terms_error ? 
                                                `<p class="text-danger"><strong>Error:</strong> ${data.result.terms_error}</p>` : 
                                                ''
                                            }
                                        </div>
                                    </div>
                                `;
                            }
                            
                            resultHtml += '</div>';
                        }
                        
                        resultContent.innerHTML = resultHtml;
                        
                        // Refresh jobs list (should be empty now)
                        loadAllJobs();
                    }
                } catch (error) {
                    // Show error
                    resultCard.classList.remove('d-none');
                    resultContent.innerHTML = `<div class="alert alert-danger">Error clearing database: ${error.message}</div>`;
                } finally {
                    // Hide spinner and enable button
                    clearDbSpinner.classList.add('d-none');
                    confirmClearDbButton.disabled = false;
                }
            });
            
            // Load available models
            async function loadAvailableModels() {
                try {
                    const response = await fetch('/api/models');
                    if (response.ok) {
                        const data = await response.json();
                        if (data.status === 'success' && data.models && data.models.length > 0) {
                            // Populate model dropdowns
                            const enrichmentModel = document.getElementById('enrichment-model');
                            const questionsModel = document.getElementById('questions-model');
                            const embeddingModel = document.getElementById('embedding-model');
                            
                            // Clear existing options except the first one
                            while (enrichmentModel.options.length > 1) {
                                enrichmentModel.remove(1);
                            }
                            while (questionsModel.options.length > 1) {
                                questionsModel.remove(1);
                            }
                            while (embeddingModel.options.length > 1) {
                                embeddingModel.remove(1);
                            }
                            
                            // Add models to the dropdowns
                            data.models.forEach(model => {
                                // Skip embedding models for text generation dropdowns
                                if (model.includes('all-minilm') || model.includes('embed')) {
                                    // Add only to embedding dropdown
                                    const option = document.createElement('option');
                                    option.value = model;
                                    option.text = model;
                                    embeddingModel.appendChild(option);
                                } else {
                                    // Add to text generation dropdowns
                                    const option1 = document.createElement('option');
                                    option1.value = model;
                                    option1.text = model;
                                    enrichmentModel.appendChild(option1.cloneNode(true));
                                    
                                    const option2 = document.createElement('option');
                                    option2.value = model;
                                    option2.text = model;
                                    questionsModel.appendChild(option2);
                                }
                            });
                        }
                    }
                } catch (error) {
                    console.error('Error loading models:', error);
                }
            }
            
            // Load models when the page loads
            loadAvailableModels();
            
            // Process form submission
            processForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                // Show spinner and disable button
                processSpinner.classList.remove('d-none');
                processButton.disabled = true;
                
                // Hide result cards
                resultCard.classList.add('d-none');
                jobStatusCard.classList.add('d-none');
                
                // Get form values
                const enableChunking = enableChunkingSwitch.checked;
                const chunkSize = document.getElementById('chunk-size').value;
                const minSize = document.getElementById('min-size').value;
                const overlap = document.getElementById('overlap').value;
                const enableEnrichment = document.getElementById('enable-enrichment').checked;
                const enableQuestions = enableQuestionsSwitch.checked;
                const maxQuestions = document.getElementById('max-questions').value;
                const enrichmentModel = document.getElementById('enrichment-model').value;
                const questionsModel = document.getElementById('questions-model').value;
                const embeddingModel = document.getElementById('embedding-model').value;
                
                // Create form data
                const formData = new FormData();
                formData.append('enable_chunking', enableChunking);
                formData.append('chunk_size', chunkSize);
                formData.append('min_size', minSize);
                formData.append('overlap', overlap);
                formData.append('enhance_chunks', enableEnrichment);
                formData.append('generate_questions', enableQuestions);
                formData.append('max_questions_per_chunk', maxQuestions);
                formData.append('enrichment_model', enrichmentModel);
                formData.append('questions_model', questionsModel);
                formData.append('embedding_model', embeddingModel);
                
                try {
                    // Send request to start processing
                    const response = await fetch('/process-documents', {
                        method: 'POST',
                        body: formData
                    });
                    
                    const data = await response.json();
                    
                    if (data.status === 'error') {
                        // Show error
                        resultCard.classList.remove('d-none');
                        resultContent.innerHTML = `<div class="alert alert-danger">${data.message}</div>`;
                    } else {
                        // Get the job ID and start tracking progress
                        const jobId = data.job_id;
                        
                        // Setup the job status card
                        currentJobId = jobId;
                        jobIdDisplay.textContent = jobId.substring(0, 8) + '...';
                        jobStatusCard.classList.remove('d-none');
                        
                        // Start polling for updates
                        startPolling(jobId);
                        
                        // Load all jobs
                        loadAllJobs();
                    }
                } catch (error) {
                    // Show error
                    resultCard.classList.remove('d-none');
                    resultContent.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
                } finally {
                    // Hide spinner and enable button
                    processSpinner.classList.add('d-none');
                    processButton.disabled = false;
                }
            });
            
            // Polling control event listeners
            stopPollingBtn.addEventListener('click', stopPolling);
            resumePollingBtn.addEventListener('click', resumePolling);
            refreshJobsBtn.addEventListener('click', loadAllJobs);
            
            // Load all jobs on page load
            loadAllJobs();
        });
    </script>
    <style>
        .job-stats .stat-item {
            border: 1px solid #eee;
            border-radius: 5px;
            padding: 10px;
            background-color: #f9f9f9;
        }
        .job-stats .stat-value {
            font-size: 24px;
            font-weight: bold;
        }
        .job-stats .stat-label {
            font-size: 14px;
            color: #666;
        }
        .job-id-badge {
            font-family: monospace;
        }
    </style>
</body>
</html>